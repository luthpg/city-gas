import fs from 'node:fs';
import path from 'node:path';
import fg from 'fast-glob';
import ts from 'typescript';
import { type DSL, dslToTs } from '@/plugin/dslToTs';

function extractParams(filePath: string): Record<string, any> | undefined {
  const content = fs.readFileSync(filePath, 'utf-8');
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true,
  );

  let paramsNode: ts.Node | undefined;

  function findParams(node: ts.Node) {
    if (
      ts.isVariableStatement(node) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      for (const decl of node.declarationList.declarations) {
        if (decl.name.getText(sourceFile) === 'params') {
          paramsNode = decl.initializer;
          break;
        }
      }
    }
    if (!paramsNode) {
      ts.forEachChild(node, findParams);
    }
  }

  findParams(sourceFile);

  if (paramsNode) {
    const paramsText = paramsNode.getText(sourceFile);
    try {
      return new Function(`return (${paramsText})`)();
    } catch (e) {
      console.error(`Error evaluating params from ${filePath}:`, e);
    }
  }

  return undefined;
}

function pathToRouteName(pagesDir: string, filePath: string): string {
  const relativePath = path.relative(pagesDir, filePath);
  const posixPath = relativePath.replace(/\\/g, '/');
  const withoutExt = posixPath.replace(/\.[^/.]+$/, '');

  if (withoutExt.endsWith('/index')) {
    return withoutExt.slice(0, -6);
  }
  if (withoutExt === 'index') {
    return '';
  }
  return withoutExt;
}

function generateTypeContent(
  routes: { name: string; params?: Record<string, DSL> }[],
) {
  const routeNames =
    routes.map((r) => JSON.stringify(r.name)).join(' | ') || 'never';

  const routeParams = routes

    .map((r) => {
      if (!r.params) return `    ${JSON.stringify(r.name)}: {};`;

      const paramsType = dslToTs({ type: 'object', shape: r.params });

      return `    ${JSON.stringify(r.name)}: ${paramsType};`;
    })

    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas\n\nexport type RouteNames = ${routeNames};\n\nexport interface RouteParams {\n${routeParams}\n}\n`;
}

function generateRoutesContent(
  rootDir: string,
  routes: { path: string; name: string }[],
) {
  const imports = routes

    .map((r, i) => {
      const importPath = path
        .relative(path.resolve(rootDir, 'src/generated'), r.path)
        .replace(/\\/g, '/')
        .replace(/\.[^/.]+$/, '');

      return `import P${i} from '${importPath}';`;
    })

    .join('\n');

  const pages = routes

    .map((r, i) => `  ${JSON.stringify(r.name)}: P${i},`)

    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas\n\n${imports}\n\nexport const pages = {\n${pages}\n};\n`;
}

export async function generate(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');

  const files = await fg(path.join(pagesDir, '**/*.tsx').replace(/\\/g, '/'));

  const routes = files.map((file) => ({
    path: file,

    name: pathToRouteName(pagesDir, file),

    params: extractParams(file),
  }));

  // Generate types

  const typeContent = generateTypeContent(routes);

  const typeOutputPath = path.resolve(rootDir, 'src/generated/router.d.ts');

  fs.mkdirSync(path.dirname(typeOutputPath), { recursive: true });

  fs.writeFileSync(typeOutputPath, typeContent, 'utf-8');

  console.log(`[city-gas] Generated types in ${typeOutputPath}`);

  // Generate routes map

  const routesContent = generateRoutesContent(rootDir, routes);

  const routesOutputPath = path.resolve(rootDir, 'src/generated/routes.ts');

  fs.writeFileSync(routesOutputPath, routesContent, 'utf-8');

  console.log(`[city-gas] Generated routes map in ${routesOutputPath}`);

  return routes;
}
