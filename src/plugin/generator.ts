import fs from 'node:fs';
import path from 'node:path';
import { parse } from '@vue/compiler-sfc';
import fg from 'fast-glob';
import ts from 'typescript';
import { type DSL, dslToTs } from '@/plugin/dslToTs';

function extractParamsFromTs(
  filePath: string,
  content: string,
): Record<string, any> | undefined {
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true,
  );

  let paramsNode: ts.Node | undefined;

  function findParams(node: ts.Node) {
    if (
      ts.isVariableStatement(node) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      for (const decl of node.declarationList.declarations) {
        if (decl.name.getText(sourceFile) === 'params') {
          paramsNode = decl.initializer;
          break;
        }
      }
    }
    if (!paramsNode) {
      ts.forEachChild(node, findParams);
    }
  }

  findParams(sourceFile);

  if (paramsNode) {
    const paramsText = paramsNode.getText(sourceFile);
    try {
      return new Function(`return (${paramsText})`)();
    } catch (e) {
      console.error(`Error evaluating params from ${filePath}:`, e);
    }
  }

  return undefined;
}

function extractParams(filePath: string): Record<string, any> | undefined {
  const content = fs.readFileSync(filePath, 'utf-8');
  if (filePath.endsWith('.vue')) {
    const { descriptor } = parse(content);
    const script =
      descriptor.scriptSetup?.content || descriptor.script?.content;
    if (script) {
      return extractParamsFromTs(filePath, script);
    }
    return {};
  } else {
    return extractParamsFromTs(filePath, content);
  }
}

function pathToRouteName(pagesDir: string, filePath: string): string {
  const relativePath = path.relative(pagesDir, filePath);
  const posixPath = relativePath.replace(/\\/g, '/');
  const withoutExt = posixPath.replace(/\.[^/.]+$/, '');

  if (withoutExt.endsWith('/index')) {
    return withoutExt.slice(0, -6);
  }
  if (withoutExt === 'index') {
    return '';
  }
  return withoutExt;
}

function generateTypeContent(
  routes: { name: string; params?: Record<string, DSL> }[],
) {
  const routeNames =
    routes.map((r) => JSON.stringify(r.name)).join(' | ') || 'never';

  const routeParams = routes
    .map((r) => {
      if (!r.params) return `  ${JSON.stringify(r.name)}: {};`;
      const paramsType = dslToTs({ type: 'object', shape: r.params });
      return `  ${JSON.stringify(r.name)}: ${paramsType};`;
    })
    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas
// @ts-nocheck
/* eslint-disable */
/* biome-ignore: auto generated file */

export type RouteNames = ${routeNames};

export interface RouteParams {
${routeParams}
}

declare module '@ciderjs/city-gas' {
  interface Register {
    RouteNames: RouteNames;
    RouteParams: RouteParams;
  }
}
`;
}

function generateRoutesContent(
  rootDir: string,
  routes: { path: string; name: string }[],
) {
  const imports = routes
    .map((r, i) => {
      const importPath = path
        .relative(path.resolve(rootDir, 'src/generated'), r.path)
        .replace(/\\/g, '/')
        .replace(/\.[^/.]+$/, '');
      return `import P${i} from '${importPath}';`;
    })
    .join('\n');

  const pages = routes
    .map((r, i) => `  ${JSON.stringify(r.name)}: P${i},`)
    .join('\n');
  return `// Auto-generated by @ciderjs/city-gas\n\n${imports}\n\nexport const pages = {\n${pages}\n};\n`;
}

export async function generate(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');
  const files = await fg(
    path.join(pagesDir, '**/*.{tsx,vue}').replace(/\\/g, '/'),
  );
  const routes = files.map((file) => ({
    path: file,
    name: pathToRouteName(pagesDir, file),
    params: extractParams(file),
  }));

  // Generate types
  const typeContent = generateTypeContent(routes);
  const typeOutputPath = path.resolve(rootDir, 'src/generated/router.d.ts');
  fs.mkdirSync(path.dirname(typeOutputPath), { recursive: true });
  fs.writeFileSync(typeOutputPath, typeContent, 'utf-8');
  console.log(`[city-gas] Generated types in ${typeOutputPath}`);

  // Generate routes map
  const routesContent = generateRoutesContent(rootDir, routes);
  const routesOutputPath = path.resolve(rootDir, 'src/generated/routes.ts');
  fs.writeFileSync(routesOutputPath, routesContent, 'utf-8');
  console.log(`[city-gas] Generated routes map in ${routesOutputPath}`);

  return routes;
}
