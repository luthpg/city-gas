import crypto from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import { parse } from '@vue/compiler-sfc';
import fg from 'fast-glob';
import ts from 'typescript';
import { zodToTs } from '@/plugin/zodToTs';

interface FileCacheEntry {
  schemaType: string; // TSの型定義文字列 (例: "{ tab?: string | undefined }")
  hasSchema: boolean; // export const schema が存在するか
  mtimeMs: number;
}

const fileCache = new Map<string, FileCacheEntry>();
const contentCache = {
  dts: '',
  routes: '',
};

/**
 * ファイルパスからパスパラメータを抽出
 * 例: "users/[userId].tsx" -> ["userId"]
 */
function getPathParams(routeName: string): string[] {
  const matches = routeName.match(/\[([^\][]+)\]/g);
  if (!matches) return [];
  return matches.map((m) => m.slice(1, -1));
}

/**
 * TS/TSX コンテンツから export const schema を解析する
 */
function extractSchemaFromTs(
  filePath: string,
  content: string,
): { schemaType: string; hasSchema: boolean } {
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true,
  );

  let schemaNode: ts.Expression | undefined;

  function findSchema(node: ts.Node) {
    if (
      ts.isVariableStatement(node) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      for (const decl of node.declarationList.declarations) {
        if (decl.name.getText(sourceFile) === 'schema' && decl.initializer) {
          schemaNode = decl.initializer;
          break;
        }
      }
    }
    if (!schemaNode) {
      ts.forEachChild(node, findSchema);
    }
  }

  findSchema(sourceFile);

  if (schemaNode) {
    // zodToTs を使って型文字列に変換
    const typeStr = zodToTs(schemaNode, sourceFile);
    return { schemaType: typeStr, hasSchema: true };
  }

  return { schemaType: '{}', hasSchema: false };
}

/**
 * ファイルからスキーマ情報を抽出 (.vue 対応)
 */
function extractSchema(filePath: string): {
  schemaType: string;
  hasSchema: boolean;
} {
  const content = fs.readFileSync(filePath, 'utf-8');
  if (filePath.endsWith('.vue')) {
    const { descriptor } = parse(content);
    // <script> または <script setup> を探す
    // 注: setup内で export const schema はできないため、
    // Vueの場合は通常の <script> ブロックで export const schema を書く想定
    const scriptContent =
      descriptor.script?.content ?? descriptor.scriptSetup?.content;

    if (scriptContent) {
      return extractSchemaFromTs(filePath, scriptContent);
    }
    return { schemaType: '{}', hasSchema: false };
  }

  return extractSchemaFromTs(filePath, content);
}

/**
 * ファイルパスからルート情報を生成
 */
function pathToRouteInfo(
  pagesDir: string,
  filePath: string,
): { name: string; isIndex: boolean } {
  const relativePath = path.relative(pagesDir, filePath);
  const posixPath = relativePath.replace(/\\/g, '/');
  const withoutExt = posixPath.replace(/\.[^/.]+$/, '');

  if (withoutExt.endsWith('/index')) {
    return { name: `/${withoutExt.slice(0, -6)}`, isIndex: true };
  }
  if (withoutExt === 'index') {
    return { name: '/', isIndex: true };
  }
  return { name: `/${withoutExt}`, isIndex: false };
}

/**
 * TypeScript型定義 (router.d.ts) の生成
 */
function generateTypeContent(routes: { name: string; schemaType: string }[]) {
  const routeNames =
    routes.map((r) => JSON.stringify(r.name)).join(' | ') || 'never';

  const routeParams = routes
    .map((r) => {
      const pathParams = getPathParams(r.name);

      // クエリパラメータの型 (ユーザー定義)
      let finalType = r.schemaType;

      // パスパラメータがある場合、交差型で結合する
      if (pathParams.length > 0) {
        // パスパラメータは常に string (URLの一部のため)
        const pathParamsType = `{ ${pathParams.map((p) => `${p}: string`).join('; ')} }`;

        // ユーザー定義が {} (空) ならパスパラメータのみ、それ以外なら & で結合
        if (finalType === '{}') {
          finalType = pathParamsType;
        } else {
          finalType = `(${finalType}) & ${pathParamsType}`;
        }
      }

      return `  ${JSON.stringify(r.name)}: ${finalType};`;
    })
    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas
// @ts-nocheck
/* eslint-disable */
/* biome-ignore: auto generated file */

export type RouteNames = ${routeNames};

export interface RouteParams {
${routeParams}
}

declare module '@ciderjs/city-gas' {
  interface Register {
    RouteNames: RouteNames;
    RouteParams: RouteParams;
  }
}
`;
}

function generateHash(filePath: string): string {
  return crypto.createHash('md5').update(filePath).digest('hex').slice(0, 8);
}

/**
 * ランタイムルートマップ (routes.ts) の生成
 */
function generateRoutesContent(
  rootDir: string,
  routes: {
    path: string;
    name: string;
    isIndex: boolean;
    hasSchema: boolean;
  }[],
  specialRoutes: { path: string; name: string }[],
) {
  const routesDir = path.dirname(
    path.resolve(rootDir, 'src/generated/routes.ts'),
  );

  // インポート文の生成
  const imports: string[] = [
    `import { z } from 'zod';`, // Zod必須
  ];

  routes.forEach((r) => {
    const importPath = path.relative(routesDir, r.path).replace(/\\/g, '/');
    const hash = generateHash(r.path);

    // コンポーネントのインポート
    imports.push(`import P_${hash} from '${importPath}';`);

    // スキーマのインポート (存在する場合のみ)
    if (r.hasSchema) {
      imports.push(`import { schema as S_${hash} } from '${importPath}';`);
    }
  });

  specialRoutes.forEach((r) => {
    const importPath = path.relative(routesDir, r.path).replace(/\\/g, '/');
    const hash = generateHash(r.path);
    imports.push(`import P_${hash} from '${importPath}';`);
  });

  // Pagesオブジェクトの生成
  const pages = routes
    .map((r) => {
      const hash = generateHash(r.path);
      const pathParams = getPathParams(r.name);

      let schemaExpression = 'z.object({})';
      if (r.hasSchema) {
        schemaExpression = `S_${hash}`;
      }

      // パスパラメータのZod定義を生成
      if (pathParams.length > 0) {
        // 例: .and(z.object({ userId: z.string() }))
        const pathSchemaObj = pathParams
          .map((p) => `${p}: z.string()`)
          .join(', ');
        // 既存スキーマがz.object以外の可能性(z.unionなど)も考慮し、.and(Intersection)を使用
        // ※ ユーザー定義がない場合は z.object({}) なので .extend() でも良いが、
        //    ユーザー定義がある場合は .and() が安全
        schemaExpression = `(${schemaExpression}).and(z.object({ ${pathSchemaObj} }))`;
      } else if (!r.hasSchema) {
        // スキーマもパスパラメータもない場合は undefined (最適化)
        // ただしRouter側でundefinedチェックが必要。ここでは一貫性のため z.object({}) を渡すか、
        // もしくは router.ts 側で fallback するなら undefined にする。
        // -> 今回は生成コード側で明示的に渡す方針にする
        schemaExpression = `z.object({})`;
      }

      return `  ${JSON.stringify(r.name)}: { 
    component: P_${hash}, 
    isIndex: ${r.isIndex},
    schema: ${schemaExpression}
  },`;
    })
    .join('\n');

  // SpecialPagesオブジェクトの生成
  const specialPages = specialRoutes
    .map((r) => {
      const hash = generateHash(r.path);
      return `  ${JSON.stringify(r.name)}: P_${hash},`;
    })
    .join('\n');

  // DynamicRoutes配列の生成 (Router Coreでのマッチング用)
  const dynamicRoutesData = routes
    .filter((r) => r.name.includes('['))
    .map((r) => {
      const paramNames = getPathParams(r.name);
      const segments = r.name.split('/');
      const patternSegments = segments.map((segment) => {
        if (segment.startsWith('[') && segment.endsWith(']')) {
          return '([^/]+)';
        }
        return segment.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
      });
      const pattern = `^${patternSegments.join('\\/')}$`;

      return `{
    name: ${JSON.stringify(r.name)},
    pattern: /${pattern}/,
    paramNames: ${JSON.stringify(paramNames)}
  }`;
    })
    .join(',\n  ');

  return `// Auto-generated by @ciderjs/city-gas
// @ts-nocheck
/* eslint-disable */
/* biome-ignore: auto generated file */

${imports.join('\n')}

export const pages = {
${pages}
};

export const specialPages = {
${specialPages}
};

export const dynamicRoutes = [
  ${dynamicRoutesData}
];
`;
}

/**
 * ファイル書き出し処理
 */
function flushFiles(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');
  const allCachedFiles = Array.from(fileCache.keys());

  const specialFileNames = ['_layout', '_root', '_404'];
  const pageFiles: string[] = [];
  const specialFiles: string[] = [];

  allCachedFiles.forEach((file) => {
    const fileName = path.basename(file, path.extname(file));
    if (specialFileNames.includes(fileName)) {
      specialFiles.push(file);
    } else {
      pageFiles.push(file);
    }
  });

  // ルート重複解決
  const routeMap = new Map<string, { path: string; isIndex: boolean }>();

  for (const file of pageFiles) {
    const { name, isIndex } = pathToRouteInfo(pagesDir, file);
    const existing = routeMap.get(name);

    if (!existing) {
      routeMap.set(name, { path: file, isIndex });
    } else {
      // 競合解決ロジック (index優先)
      if (existing.isIndex && !isIndex) {
        console.warn(
          `[city-gas] Warning: Route conflict. ${file} ignored in favor of ${existing.path} ("${name}").`,
        );
      } else if (!existing.isIndex && isIndex) {
        console.warn(
          `[city-gas] Warning: Route conflict. ${existing.path} ignored in favor of ${file} ("${name}").`,
        );
        routeMap.set(name, { path: file, isIndex });
      } else {
        console.warn(
          `[city-gas] Warning: Ambiguous conflict for "${name}". Using ${file}.`,
        );
        routeMap.set(name, { path: file, isIndex });
      }
    }
  }

  // 最終的なルートリスト
  const routes = Array.from(routeMap.entries())
    .map(([name, info]) => {
      const entry = fileCache.get(info.path);
      return {
        path: info.path,
        name,
        isIndex: info.isIndex,
        schemaType: entry?.schemaType || '{}',
        hasSchema: entry?.hasSchema || false,
      };
    })
    .sort((a, b) => a.path.localeCompare(b.path));

  const specialRoutes = specialFiles
    .map((file) => {
      const relativePath = path.relative(pagesDir, file);
      const posixPath = relativePath.replace(/\\/g, '/');
      const name = posixPath.replace(/\.[^/.]+$/, '');
      return { path: file, name };
    })
    .sort((a, b) => a.path.localeCompare(b.path));

  // 1. router.d.ts 生成
  const typeOutputPath = path.resolve(rootDir, 'src/generated/router.d.ts');
  const typeContent = generateTypeContent(routes);
  if (contentCache.dts !== typeContent) {
    fs.mkdirSync(path.dirname(typeOutputPath), { recursive: true });
    fs.writeFileSync(typeOutputPath, typeContent, 'utf-8');
    contentCache.dts = typeContent;
    console.log(`[city-gas] Generated types in ${typeOutputPath}`);
  }

  // 2. routes.ts 生成
  const routesOutputPath = path.resolve(rootDir, 'src/generated/routes.ts');
  const routesContent = generateRoutesContent(rootDir, routes, specialRoutes);
  if (contentCache.routes !== routesContent) {
    fs.mkdirSync(path.dirname(routesOutputPath), { recursive: true });
    fs.writeFileSync(routesOutputPath, routesContent, 'utf-8');
    contentCache.routes = routesContent;
    console.log(`[city-gas] Generated routes map in ${routesOutputPath}`);
  }
}

/**
 * ファイル更新時
 */
export async function updateFile(filePath: string, rootDir: string) {
  const normalizedPath = filePath.replace(/\\/g, '/');

  try {
    const stat = fs.statSync(filePath);
    const mtimeMs = stat.mtimeMs;

    const cached = fileCache.get(normalizedPath);
    if (cached && cached.mtimeMs === mtimeMs) {
      return;
    }

    // スキーマ抽出 (Zod解析)
    const { schemaType, hasSchema } = extractSchema(filePath);

    fileCache.set(normalizedPath, {
      schemaType,
      hasSchema,
      mtimeMs,
    });

    flushFiles(rootDir);
  } catch (e) {
    console.error(`[city-gas] Error processing ${filePath}:`, e);
  }
}

/**
 * ファイル削除時
 */
export async function removeFile(filePath: string, rootDir: string) {
  const normalizedPath = filePath.replace(/\\/g, '/');
  if (fileCache.has(normalizedPath)) {
    fileCache.delete(normalizedPath);
    flushFiles(rootDir);
  }
}

/**
 * 初期化 (フルスキャン)
 */
export async function generate(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');
  const allFiles = await fg(
    path.join(pagesDir, '**/*.{tsx,vue}').replace(/\\/g, '/'),
  );

  fileCache.clear();
  contentCache.dts = '';
  contentCache.routes = '';

  for (const file of allFiles) {
    try {
      const stat = fs.statSync(file);
      const { schemaType, hasSchema } = extractSchema(file);
      fileCache.set(file, {
        schemaType,
        hasSchema,
        mtimeMs: stat.mtimeMs,
      });
    } catch (e) {
      console.warn(`[city-gas] Failed to parse ${file} during init:`, e);
    }
  }

  flushFiles(rootDir);
  console.log(`[city-gas] Initialized router with ${allFiles.length} pages.`);
}
