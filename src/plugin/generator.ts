import fs from 'node:fs';
import path from 'node:path';
import { parse } from '@vue/compiler-sfc';
import fg from 'fast-glob';
import ts from 'typescript';
import { type DSL, dslToTs } from '@/plugin/dslToTs';

interface FileCacheEntry {
  params: Record<string, any> | undefined;
  mtimeMs: number;
}

const fileCache = new Map<string, FileCacheEntry>();
const contentCache = {
  dts: '',
  routes: '',
};

function getPathParams(routeName: string): string[] {
  const matches = routeName.match(/\[([^\][]+)\]/g);
  if (!matches) return [];
  return matches.map((m) => m.slice(1, -1));
}

function extractParamsFromTs(
  filePath: string,
  content: string,
): Record<string, any> | undefined {
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true,
  );
  let paramsNode: ts.ObjectLiteralExpression | undefined;

  function findParams(node: ts.Node) {
    if (
      ts.isVariableStatement(node) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      for (const decl of node.declarationList.declarations) {
        if (
          decl.name.getText(sourceFile) === 'params' &&
          decl.initializer &&
          ts.isObjectLiteralExpression(decl.initializer)
        ) {
          paramsNode = decl.initializer;
          break;
        }
      }
    }
    if (!paramsNode) {
      ts.forEachChild(node, findParams);
    }
  }

  findParams(sourceFile);

  if (paramsNode) {
    return parseObjectLiteral(paramsNode, sourceFile);
  }
  return undefined;
}

function parseObjectLiteral(
  node: ts.ObjectLiteralExpression,
  sourceFile: ts.SourceFile,
): Record<string, any> {
  const result: Record<string, any> = {};

  for (const prop of node.properties) {
    if (ts.isPropertyAssignment(prop)) {
      const key = prop.name.getText(sourceFile);
      const value = parseValue(prop.initializer, sourceFile);
      result[key] = value;
    }
  }

  return result;
}

function parseValue(node: ts.Expression, sourceFile: ts.SourceFile): any {
  if (ts.isStringLiteral(node)) {
    return node.text;
  }
  if (ts.isNumericLiteral(node)) {
    return Number(node.text);
  }
  if (node.kind === ts.SyntaxKind.TrueKeyword) {
    return true;
  }
  if (node.kind === ts.SyntaxKind.FalseKeyword) {
    return false;
  }
  if (ts.isObjectLiteralExpression(node)) {
    return parseObjectLiteral(node, sourceFile);
  }
  if (ts.isArrayLiteralExpression(node)) {
    return node.elements.map((el) => parseValue(el, sourceFile));
  }
  // Fallback: 文字列として返す
  return node.getText(sourceFile);
}

function extractParams(filePath: string): Record<string, any> | undefined {
  const content = fs.readFileSync(filePath, 'utf-8');
  if (filePath.endsWith('.vue')) {
    const { descriptor } = parse(content);
    const script =
      descriptor.script?.content ?? descriptor.scriptSetup?.content;
    if (script) {
      return extractParamsFromTs(filePath, script);
    }
    return undefined;
  } else {
    return extractParamsFromTs(filePath, content);
  }
}

function pathToRouteInfo(
  pagesDir: string,
  filePath: string,
): { name: string; isIndex: boolean } {
  const relativePath = path.relative(pagesDir, filePath);
  const posixPath = relativePath.replace(/\\/g, '/');
  const withoutExt = posixPath.replace(/\.[^/.]+$/, '');

  if (withoutExt.endsWith('/index')) {
    return { name: `/${withoutExt.slice(0, -6)}`, isIndex: true };
  }
  if (withoutExt === 'index') {
    return { name: '/', isIndex: true };
  }
  return { name: `/${withoutExt}`, isIndex: false };
}

function generateTypeContent(
  routes: { name: string; isIndex: boolean; params?: Record<string, DSL> }[],
) {
  const routeNames =
    routes.map((r) => JSON.stringify(r.name)).join(' | ') || 'never';

  const routeParams = routes
    .map((r) => {
      const pathParams = getPathParams(r.name);
      const combinedParams = { ...(r.params || {}) };

      for (const p of pathParams) {
        combinedParams[p] = 'string';
      }

      if (Object.keys(combinedParams).length === 0) {
        return `  ${JSON.stringify(r.name)}: {};`;
      }

      const paramsType = dslToTs({ type: 'object', shape: combinedParams });
      return `  ${JSON.stringify(r.name)}: ${paramsType};`;
    })
    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas
// @ts-nocheck
/* eslint-disable */
/* biome-ignore: auto generated file */

export type RouteNames = ${routeNames};

export interface RouteParams {
${routeParams}
}

declare module '@ciderjs/city-gas' {
  interface Register {
    RouteNames: RouteNames;
    RouteParams: RouteParams;
  }
}
`;
}

function generateRoutesContent(
  rootDir: string,
  routes: { path: string; name: string; isIndex: boolean }[],
  specialRoutes: { path: string; name: string }[],
) {
  const allRoutes = [...routes, ...specialRoutes];
  const imports = allRoutes
    .map((r, i) => {
      const importPath = path
        .relative(
          path.dirname(path.resolve(rootDir, 'src/generated/routes.ts')),
          r.path,
        )
        .replace(/\\/g, '/');
      return `import P${i} from '${importPath}';`;
    })
    .join('\n');

  const pages = routes
    .map(
      (r, i) =>
        `  ${JSON.stringify(r.name)}: { component: P${i}, isIndex: ${
          r.isIndex
        } },`,
    )
    .join('\n');

  const specialPages = specialRoutes
    .map((r, i) => `  ${JSON.stringify(r.name)}: P${routes.length + i},`)
    .join('\n');

  const dynamicRoutesData = routes
    .filter((r) => r.name.includes('['))
    .map((r) => {
      const paramNames = getPathParams(r.name);
      const segments = r.name.split('/');
      const patternSegments = segments.map((segment) => {
        if (segment.startsWith('[') && segment.endsWith(']')) {
          return '([^/]+)';
        }
        return segment.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
      });
      const pattern = `^${patternSegments.join('\\/')}$`;

      return `{
    name: ${JSON.stringify(r.name)},
    pattern: /${pattern}/,
    paramNames: ${JSON.stringify(paramNames)}
  }`;
    })
    .join(',\n  ');

  return `// Auto-generated by @ciderjs/city-gas
// @ts-nocheck
/* eslint-disable */
/* biome-ignore: auto generated file */

${imports}

export const pages = {
${pages}
};

export const specialPages = {
${specialPages}
};

export const dynamicRoutes = [
  ${dynamicRoutesData}
];
`;
}

/**
 * キャッシュ内の情報を使ってファイルを生成する
 * I/O は発生させない (書き込みのみ、それも変更がある場合のみ)
 */
function flushFiles(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');
  const allCachedFiles = Array.from(fileCache.keys());

  const specialFileNames = ['_layout', '_root', '_404'];
  const pageFiles: string[] = [];
  const specialFiles: string[] = [];

  allCachedFiles.forEach((file) => {
    const fileName = path.basename(file, path.extname(file));
    if (specialFileNames.includes(fileName)) {
      specialFiles.push(file);
    } else {
      pageFiles.push(file);
    }
  });

  // ルートの重複解決 (Map を使用)
  const routeMap = new Map<string, { path: string; isIndex: boolean }>();

  for (const file of pageFiles) {
    const { name, isIndex } = pathToRouteInfo(pagesDir, file);
    const existing = routeMap.get(name);

    if (!existing) {
      // 競合なし、そのまま追加
      routeMap.set(name, { path: file, isIndex });
    } else {
      // 競合発生
      if (existing.isIndex && !isIndex) {
        // 既存が index (優先)、新しいファイル (非 index) を無視
        console.warn(
          `[city-gas] Warning: Route conflict detected. ${file} is ignored because ${existing.path} takes precedence (route name: "${name}").`,
        );
      } else if (!existing.isIndex && isIndex) {
        // 新しいファイルが index (優先)、既存 (非 index) を上書き
        console.warn(
          `[city-gas] Warning: Route conflict detected. ${existing.path} is ignored because ${file} takes precedence (route name: "${name}").`,
        );
        routeMap.set(name, { path: file, isIndex });
      } else {
        // 曖昧な競合
        console.warn(
          `[city-gas] Warning: Ambiguous route conflict for "${name}". Using ${file} over ${existing.path}.`,
        );
        routeMap.set(name, { path: file, isIndex });
      }
    }
  }

  // マップから最終的なルートリストを作成
  const routes = Array.from(routeMap.entries())
    .map(([name, info]) => {
      const entry = fileCache.get(info.path);
      return {
        path: info.path,
        name,
        isIndex: info.isIndex,
        params: entry?.params,
      };
    })
    .sort((a, b) => a.path.localeCompare(b.path));

  const specialRoutes = specialFiles
    .map((file) => {
      const relativePath = path.relative(pagesDir, file);
      const posixPath = relativePath.replace(/\\/g, '/');
      const name = posixPath.replace(/\.[^/.]+$/, '');
      return {
        path: file,
        name: name,
      };
    })
    .sort((a, b) => a.path.localeCompare(b.path));

  // Generate types
  const typeOutputPath = path.resolve(rootDir, 'src/generated/router.d.ts');
  const routesOutputPath = path.resolve(rootDir, 'src/generated/routes.ts');

  const typeContent = generateTypeContent(routes);
  if (contentCache.dts !== typeContent) {
    fs.mkdirSync(path.dirname(typeOutputPath), { recursive: true });
    fs.writeFileSync(typeOutputPath, typeContent, 'utf-8');
    contentCache.dts = typeContent;
    console.log(`[city-gas] Generated types in ${typeOutputPath}`);
  }

  // 2. routes.ts
  const routesContent = generateRoutesContent(rootDir, routes, specialRoutes);
  if (contentCache.routes !== routesContent) {
    fs.mkdirSync(path.dirname(routesOutputPath), { recursive: true });
    fs.writeFileSync(routesOutputPath, routesContent, 'utf-8');
    contentCache.routes = routesContent;
    console.log(`[city-gas] Generated routes map in ${routesOutputPath}`);
  }
}

/**
 * ファイルが変更された時に呼ばれる
 * キャッシュを更新し、ファイルを再生成する
 */
export async function updateFile(filePath: string, rootDir: string) {
  // Windowsパスの正規化
  const normalizedPath = filePath.replace(/\\/g, '/');

  try {
    const stat = fs.statSync(filePath);
    const mtimeMs = stat.mtimeMs;

    // 更新時刻が変わっていないなら何もしない (Viteが検知しても中身が変わらない場合があるため)
    const cached = fileCache.get(normalizedPath);
    if (cached && cached.mtimeMs === mtimeMs) {
      return;
    }

    // params抽出
    const params = extractParams(filePath);

    // キャッシュ更新
    fileCache.set(normalizedPath, {
      params,
      mtimeMs,
    });

    // 再生成
    flushFiles(rootDir);
  } catch (e) {
    // ファイルが削除されている場合など
    console.error(`[city-gas] Error processing ${filePath}:`, e);
  }
}

/**
 * ファイルが削除された時に呼ばれる
 */
export async function removeFile(filePath: string, rootDir: string) {
  const normalizedPath = filePath.replace(/\\/g, '/');
  if (fileCache.has(normalizedPath)) {
    fileCache.delete(normalizedPath);
    flushFiles(rootDir);
  }
}

/**
 * 初回起動時 (またはフルスキャン時) に呼ばれる
 * 全ファイルを読み込んでキャッシュを構築し、生成する
 */
export async function generate(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');
  const allFiles = await fg(
    path.join(pagesDir, '**/*.{tsx,vue}').replace(/\\/g, '/'),
  );

  // キャッシュをリセット (念のため)
  fileCache.clear();
  contentCache.dts = '';
  contentCache.routes = '';

  for (const file of allFiles) {
    try {
      const stat = fs.statSync(file);
      const params = extractParams(file);
      fileCache.set(file, {
        params,
        mtimeMs: stat.mtimeMs,
      });
    } catch (e) {
      console.warn(`[city-gas] Failed to parse ${file} during init:`, e);
    }
  }

  flushFiles(rootDir);
  console.log(`[city-gas] Initialized router with ${allFiles.length} pages.`);
}
