import fs from 'node:fs';
import path from 'node:path';
import { parse } from '@vue/compiler-sfc';
import fg from 'fast-glob';
import ts from 'typescript';
import { type DSL, dslToTs } from '@/plugin/dslToTs';

function extractParamsFromTs(
  filePath: string,
  content: string,
): Record<string, any> | undefined {
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true,
  );

  let paramsNode: ts.Node | undefined;

  function findParams(node: ts.Node) {
    if (
      ts.isVariableStatement(node) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      for (const decl of node.declarationList.declarations) {
        if (decl.name.getText(sourceFile) === 'params') {
          paramsNode = decl.initializer;
          break;
        }
      }
    }
    if (!paramsNode) {
      ts.forEachChild(node, findParams);
    }
  }

  findParams(sourceFile);

  if (paramsNode) {
    const paramsText = paramsNode.getText(sourceFile);
    try {
      return new Function(`return (${paramsText})`)();
    } catch (e) {
      console.error(`Error evaluating params from ${filePath}:`, e);
    }
  }

  return undefined;
}

function extractParams(filePath: string): Record<string, any> | undefined {
  const content = fs.readFileSync(filePath, 'utf-8');
  if (filePath.endsWith('.vue')) {
    const { descriptor } = parse(content);
    const script =
      descriptor.script?.content ?? descriptor.scriptSetup?.content;
    if (script) {
      return extractParamsFromTs(filePath, script);
    }
    return undefined;
  } else {
    return extractParamsFromTs(filePath, content);
  }
}

function pathToRouteInfo(
  pagesDir: string,
  filePath: string,
): { name: string; isIndex: boolean } {
  const relativePath = path.relative(pagesDir, filePath);
  const posixPath = relativePath.replace(/\\/g, '/');
  const withoutExt = posixPath.replace(/\.[^/.]+$/, '');

  if (withoutExt.endsWith('/index')) {
    return { name: `/${withoutExt.slice(0, -6)}`, isIndex: true };
  }
  if (withoutExt === 'index') {
    return { name: '/', isIndex: true };
  }
  return { name: `/${withoutExt}`, isIndex: false };
}

function generateTypeContent(
  routes: { name: string; isIndex: boolean; params?: Record<string, DSL> }[],
) {
  const routeNames =
    routes.map((r) => JSON.stringify(r.name)).join(' | ') || 'never';

  const routeParams = routes
    .map((r) => {
      if (!r.params) return `  ${JSON.stringify(r.name)}: {};`;
      const paramsType = dslToTs({ type: 'object', shape: r.params });
      return `  ${JSON.stringify(r.name)}: ${paramsType};`;
    })
    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas
// @ts-nocheck
/* eslint-disable */
/* biome-ignore: auto generated file */

export type RouteNames = ${routeNames};

export interface RouteParams {
${routeParams}
}

declare module '@ciderjs/city-gas' {
  interface Register {
    RouteNames: RouteNames;
    RouteParams: RouteParams;
  }
}
`;
}

function generateRoutesContent(
  rootDir: string,
  routes: { path: string; name: string; isIndex: boolean }[],
  specialRoutes: { path: string; name: string }[],
) {
  const allRoutes = [...routes, ...specialRoutes];
  const imports = allRoutes
    .map((r, i) => {
      const importPath = path
        .relative(
          path.dirname(path.resolve(rootDir, 'src/generated/routes.ts')),
          r.path,
        )
        .replace(/\\/g, '/');
      return `import P${i} from '${importPath}';`;
    })
    .join('\n');

  const pages = routes
    .map(
      (r, i) =>
        `  ${JSON.stringify(r.name)}: { component: P${i}, isIndex: ${
          r.isIndex
        } },`,
    )
    .join('\n');

  const specialPages = specialRoutes
    .map((r, i) => `  ${JSON.stringify(r.name)}: P${routes.length + i},`)
    .join('\n');

  return `// Auto-generated by @ciderjs/city-gas

${imports}

export const pages = {
${pages}
};

export const specialPages = {
${specialPages}
};
`;
}

export async function generate(rootDir: string) {
  const pagesDir = path.resolve(rootDir, 'src/pages');
  const allFiles = await fg(
    path.join(pagesDir, '**/*.{tsx,vue}').replace(/\\/g, '/'),
  );

  const specialFileNames = ['_layout', '_root', '_404'];
  const pageFiles: string[] = [];
  const specialFiles: string[] = [];

  allFiles.forEach((file) => {
    const fileName = path.basename(file, path.extname(file));
    if (specialFileNames.includes(fileName)) {
      specialFiles.push(file);
    } else {
      pageFiles.push(file);
    }
  });

  // 2. ルートの重複解決 (Map を使用)
  const routeMap = new Map<string, { path: string; isIndex: boolean }>();

  for (const file of pageFiles) {
    const { name, isIndex } = pathToRouteInfo(pagesDir, file);
    const existing = routeMap.get(name);

    if (!existing) {
      // 競合なし、そのまま追加
      routeMap.set(name, { path: file, isIndex });
    } else {
      // 競合発生
      if (existing.isIndex && !isIndex) {
        // 既存が index (優先)、新しいファイル (非 index) を無視
        console.warn(
          `[city-gas] Warning: Route conflict detected. ${file} is ignored because ${existing.path} takes precedence (route name: "${name}").`,
        );
      } else if (!existing.isIndex && isIndex) {
        // 新しいファイルが index (優先)、既存 (非 index) を上書き
        console.warn(
          `[city-gas] Warning: Route conflict detected. ${existing.path} is ignored because ${file} takes precedence (route name: "${name}").`,
        );
        routeMap.set(name, { path: file, isIndex });
      } else {
        // 両方 index または両方非 index (通常は発生しないが、念のため)
        // 最後に処理されたファイルを採用する
        console.warn(
          `[city-gas] Warning: Ambiguous route conflict for "${name}". Using ${file} over ${existing.path}.`,
        );
        routeMap.set(name, { path: file, isIndex });
      }
    }
  }

  // 3. マップから最終的なルートリストを作成
  const routes = Array.from(routeMap.entries()).map(([name, info]) => {
    return {
      path: info.path,
      name,
      isIndex: info.isIndex,
      params: extractParams(info.path), // パラメータ抽出は最後に行う
    };
  });

  const specialRoutes = specialFiles.map((file) => {
    const relativePath = path.relative(pagesDir, file);
    const posixPath = relativePath.replace(/\\/g, '/');
    const name = posixPath.replace(/\.[^/.]+$/, '');
    return {
      path: file,
      name: name,
    };
  });

  // Generate types
  const typeContent = generateTypeContent(routes);
  const typeOutputPath = path.resolve(rootDir, 'src/generated/router.d.ts');
  fs.mkdirSync(path.dirname(typeOutputPath), { recursive: true });
  fs.writeFileSync(typeOutputPath, typeContent, 'utf-8');
  console.log(`[city-gas] Generated types in ${typeOutputPath}`);

  // Generate routes map
  const routesContent = generateRoutesContent(rootDir, routes, specialRoutes);
  const routesOutputPath = path.resolve(rootDir, 'src/generated/routes.ts');
  fs.writeFileSync(routesOutputPath, routesContent, 'utf-8');
  console.log(`[city-gas] Generated routes map in ${routesOutputPath}`);

  return routes;
}
